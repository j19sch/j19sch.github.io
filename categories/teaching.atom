<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet href="https://j19sch.github.io/assets/xml/atom.xsl" type="text/xsl media="all"?>
<feed xml:lang="en" xmlns="http://www.w3.org/2005/Atom">
  <title>Joep Schuurkes (Posts about teaching)</title>
  <id>https://j19sch.github.io/categories/teaching.atom</id>
  <updated>2021-04-23T11:41:57Z</updated>
  <author>
    <name>Joep Schuurkes</name>
  </author>
  <link rel="self" type="application/atom+xml" href="https://j19sch.github.io/categories/teaching.atom"/>
  <link rel="alternate" type="text/html" href="https://j19sch.github.io/categories/teaching/"/>
  <generator uri="https://getnikola.com/">Nikola</generator>
  <entry>
    <title>VIPT - how to teach software testing</title>
    <id>https://j19sch.github.io/blog/2012/vipt-how-to-teach-software-testing/</id>
    <updated>2012-07-29T16:24:51+02:00</updated>
    <published>2012-07-29T16:24:51+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/2012/vipt-how-to-teach-software-testing/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;In this final post on VIPT (Value-Information-Processes-Tools) it's time to take a look at teaching software testing. My previous posts on VIPT can be found &lt;a href="https://testingcurve.wordpress.com/2012/07/09/yet-another-testing-model-value-information-processes-value/"&gt;here&lt;/a&gt;, &lt;a href="https://testingcurve.wordpress.com/2012/07/15/vipt-intermezzo-models-and-the-unix-philosophy/"&gt;here&lt;/a&gt; and &lt;a href="https://testingcurve.wordpress.com/2012/07/17/vipt-bottom-up-or-top-down/"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;A typical software testing course&lt;/h3&gt;
&lt;p&gt;A typical traditional software testing course (at least in the way I have taught them) has three elements: theory, stories and exercises.&lt;/p&gt;
&lt;p&gt;The first element is all about definitions (testing, test cases, defects, etc.), process descriptions and testing techniques (mostly test design). So basically what happens is that students get a brief introduction about testing in general and then we move on to the main part: teaching a specifc testing method.&lt;/p&gt;
&lt;p&gt;The second element of the course are the stories. These are mostly stories aobut how testing in the real world does not work as described in the theory. At best they are stories containing all four elements of VIPT. Most of the time, however, they are just real-world examples of a certain definition or technique.&lt;/p&gt;
&lt;p&gt;Finally, there are exercises. As with the techniques, these are mostly about test design. Unfortunately they are also very linear. There is only one correct answer and often only one correct way to get to that answer. So the main gist seems to be: "I taught you a trick, now show me you can perform the trick." But shouldn't learning about testing be more than learning to jump through a hoop on command?&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/2012/vipt-how-to-teach-software-testing/"&gt;Read moreâ€¦&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="context-driven-testing" label="context-driven testing"/>
    <category term="models" label="models"/>
    <category term="teaching" label="teaching"/>
    <category term="vipt" label="VIPT"/>
  </entry>
</feed>
