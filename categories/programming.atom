<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet href="https://j19sch.github.io/assets/xml/atom.xsl" type="text/xsl media="all"?>
<feed xml:lang="en" xmlns="http://www.w3.org/2005/Atom">
  <title>Joep Schuurkes (Posts about programming)</title>
  <id>https://j19sch.github.io/categories/programming.atom</id>
  <updated>2021-05-08T11:14:02Z</updated>
  <author>
    <name>Joep Schuurkes</name>
  </author>
  <link rel="self" type="application/atom+xml" href="https://j19sch.github.io/categories/programming.atom"/>
  <link rel="alternate" type="text/html" href="https://j19sch.github.io/categories/programming/"/>
  <generator uri="https://getnikola.com/">Nikola</generator>
  <entry>
    <title>(clj 6) Three chapters in one year</title>
    <id>https://j19sch.github.io/blog/clojure/2021/clj6-three-chapters-in-one-year/</id>
    <updated>2021-05-08T10:53:25+02:00</updated>
    <published>2021-05-08T10:53:25+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clojure/2021/clj6-three-chapters-in-one-year/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;It's been a bit more than a year since I posted my &lt;a href="https://j19sch.github.io/blog/clojure/2020/clj0-diving-straight-in/"&gt;first blog post&lt;/a&gt; about learning Clojure. And it's been five months since my &lt;a href="https://j19sch.github.io/blog/clojure/2021/clj6-three-chapters-in-one-year/clj5-loop-and-recur-into-and-conj"&gt;last blog post&lt;/a&gt; about it. So far I've made it through the first three chapters&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://j19sch.github.io/blog/clojure/2021/clj6-three-chapters-in-one-year/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt; of "&lt;a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/"&gt;Clojure for the Brave and True&lt;/a&gt;". Instead of commenting on my learning pace at the start of every post, I've decided that this pace is the pace that works for me at this time, so there's no need to keep revisiting the topic.&lt;/p&gt;
&lt;p&gt;Something I do want to mention is that one thing that triggered me to do some more Clojure was &lt;a href="https://itrevolution.com/the-idealcast-episode-10/"&gt;this episode&lt;/a&gt; of Gene Kim's excellent &lt;a href="https://itrevolution.com/the-idealcast-podcast/"&gt;Idealcast&lt;/a&gt; podcast with &lt;a href="https://www.michaelnygard.com/"&gt;Michael Nygard&lt;/a&gt;, in which they spend some time talking about Clojure.&lt;/p&gt;
&lt;h3&gt;Vim macros&lt;/h3&gt;
&lt;p&gt;The exercises got me to try out a lot of things, so I got bored having to type in the commands to copy a line (&lt;code&gt;yy&lt;/code&gt;), paste it (&lt;code&gt;p&lt;/code&gt;), replace it by its evaluation (&lt;code&gt;c!$&lt;/code&gt;), comment it out (&lt;code&gt;gcc&lt;/code&gt;), and add a "&lt;code&gt;=&amp;gt;&lt;/code&gt;" to markt it as output. So I learned about Vim macros and recorded that sequence to run when I hit &lt;code&gt;@c&lt;/code&gt;. At the end of my &lt;a href="https://j19sch.github.io/"&gt;(clj 4)&lt;/a&gt; post I mentioned I might have to do this. Guess that moment came sooner than I expected.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clojure/2021/clj6-three-chapters-in-one-year/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="brave-clojure" label="brave clojure"/>
    <category term="clojure" label="clojure"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>(clj 5) Loop and recur, into and conj</title>
    <id>https://j19sch.github.io/blog/clojure/2020/clj5-loop-and-recur-into-and-conj/</id>
    <updated>2020-12-26T10:09:08+01:00</updated>
    <published>2020-12-26T10:09:08+01:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clojure/2020/clj5-loop-and-recur-into-and-conj/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;Yet again it's been a while since I did some Clojure or blogged about it. This time I'm writing this blog post
three months after working on the code on September 5, 6 and 12. I'm not going to dwell on that too long, because
other things in my life were more important. I did feel a little sad when this year's &lt;a href="https://adventofcode.com/"&gt;Advent of Code&lt;/a&gt;
launched and I realized my Clojure is nowhere near a state where I could attempt the puzzles. So I ended up doing
the first 10 days in Python, which is twice as far as I got last year.&lt;/p&gt;
&lt;p&gt;I also feel like my current approach to learning lends itself well enough to going slow. Taking my time to play around
and make notes with while working through a section of &lt;a href="https://www.braveclojure.com/"&gt;Clojure for the Brave and True&lt;/a&gt;
and then revisiting my code and notes later to write a blog post, does seem to result in stuff actually sticking in my memory.
(Disclaimer: am writing this before writing the rest of this blog post.) Slow is smooth and smooth is fast, as they say.&lt;/p&gt;
&lt;p&gt;The section I tackled in September is "Pulling It All Together" from Chapter 3, which describes the construction of a 
piece of code of about 50 lines in which - I'm sorry to say -  a hobbit gets hit in different body parts.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clojure/2020/clj5-loop-and-recur-into-and-conj/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="brave-clojure" label="brave clojure"/>
    <category term="clojure" label="clojure"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>(clj 4) Learning about when, maps and closures</title>
    <id>https://j19sch.github.io/blog/clojure/2020/clj4-learning-when-maps-closures/</id>
    <updated>2020-07-31T22:25:15+02:00</updated>
    <published>2020-07-31T22:25:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clojure/2020/clj4-learning-when-maps-closures/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;It's been more than two months since I did any Clojure - for the obvious reasons. Luckily I did take notes as I proceeded with chapter 3 of "&lt;a href="https://www.braveclojure.com/"&gt;Clojure for the Brave and True&lt;/a&gt;". So the plan is to process these notes into a blog post, which means this post will cover the sections "Data Structures" and "Functions" of that third chapter. Leaving me ready to proceed with the rest of the chapter, i.e. "Pulling It All Together" and the summary and exercises.&lt;/p&gt;
&lt;h3&gt;Why is there a &lt;code&gt;when&lt;/code&gt;?&lt;/h3&gt;
&lt;p&gt;The part about control flow is actually before the part about &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; which I talked about in my &lt;a href="https://j19sch.github.io/blog/clojure/2020/clj3-and-or-being-weird/"&gt;previous post&lt;/a&gt;, but according to my notes I returned to it. I don't remember why to be honest.&lt;/p&gt;
&lt;p&gt;The book provides the following example of &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"Success!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;"abra cadabra"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; Success!&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; "abra cadabra"&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clojure/2020/clj4-learning-when-maps-closures/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="brave-clojure" label="brave clojure"/>
    <category term="clojure" label="clojure"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>(clj 3) Clojure's 'and' and 'or' are weird (but not really)</title>
    <id>https://j19sch.github.io/blog/clojure/2020/clj3-and-or-being-weird/</id>
    <updated>2020-05-16T21:25:15+02:00</updated>
    <published>2020-05-16T21:25:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clojure/2020/clj3-and-or-being-weird/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;Early in &lt;a href="https://www.braveclojure.com/do-things/#Control_Flow"&gt;chapter 3&lt;/a&gt; of the &lt;a href="https://www.braveclojure.com/"&gt;Brave and True&lt;/a&gt;-book the Boolean operators &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; are introduced:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Clojure uses the Boolean operators &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;. &lt;code&gt;or&lt;/code&gt; returns either the first truthy value or the last value. &lt;code&gt;and&lt;/code&gt; returns the first falsey value or, if no values are falsey, the last truthy value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This explanation is followed by some examples:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;false&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt; &lt;span class="ss"&gt;:large_I_mean_venti&lt;/span&gt; &lt;span class="ss"&gt;:why_cant_I_just_say_large&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; :large_I_mean_venti&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"yes"&lt;/span&gt; &lt;span class="s"&gt;"no"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; false&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;and&lt;/span&gt; &lt;span class="ss"&gt;:free_wifi&lt;/span&gt; &lt;span class="ss"&gt;:hot_coffee&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; :hot_coffee&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;and&lt;/span&gt; &lt;span class="ss"&gt;:feelin_super_cool&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt; &lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; nil&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What I found remarkable about this is that &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; do not return a boolean in all cases. Before I go into that, let's back up a second and cover their basics in a little more depth first.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clojure/2020/clj3-and-or-being-weird/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="brave-clojure" label="brave clojure"/>
    <category term="clojure" label="clojure"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>(clj 2) Setting up Vim for Clojure</title>
    <id>https://j19sch.github.io/blog/clojure/2020/clj2-setting-up-vim/</id>
    <updated>2020-05-05T21:55:15+02:00</updated>
    <published>2020-05-05T21:55:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clojure/2020/clj2-setting-up-vim/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;As mentioned in my &lt;a href="https://j19sch.github.io/blog/clojure/2020/clj1-deciding-on-an-editor/"&gt;previous post&lt;/a&gt; I've decided to use &lt;a href="https://www.vim.org/"&gt;Vim&lt;/a&gt; as my Clojure editor. That leaves me with three things to do: getting reacquainted with Vim, updating my Vim config in the .&lt;code&gt;vimrc&lt;/code&gt; file, and installing both general and Clojure-specific Vim plugins.&lt;/p&gt;
&lt;h3&gt;Getting reacquainted with Vim&lt;/h3&gt;
&lt;p&gt;Ever since I learned Vim basics a long time ago I have been using it once in a while to make small edits to a config file or a commit message, but not for anything more complicated than that. So that's the first thing I wanted to address: refresh my basics and make sure I know where to find more information when I need it.&lt;/p&gt;
&lt;h4&gt;Vimtutor&lt;/h4&gt;
&lt;p&gt;I figured that a good way to get back into Vim was the &lt;a href="https://vimhelp.org/usr_01.txt.html#vimtutor"&gt;Vimtutor&lt;/a&gt;. It's a 30-minute interactive tutorial where you edit a file with instructions with vim. I kept notes of what it covers, which you can find &lt;a href="https://j19sch.github.io/my-projects/vimtutor"&gt;here&lt;/a&gt;. Vim's help also includes a &lt;a href="https://vimhelp.org/quickref.txt.html"&gt;quickref&lt;/a&gt;, an "Overview of the most common commands you will use", which is intimidatingly long considering that description. As a reference to look things up in, it should be useful, though.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clojure/2020/clj2-setting-up-vim/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="clojure" label="clojure"/>
    <category term="programming" label="programming"/>
    <category term="vim" label="vim"/>
  </entry>
  <entry>
    <title>(clj 1) Deciding on a Clojure editor</title>
    <id>https://j19sch.github.io/blog/clojure/2020/clj1-deciding-on-an-editor/</id>
    <updated>2020-05-01T18:00:15+02:00</updated>
    <published>2020-05-01T18:00:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clojure/2020/clj1-deciding-on-an-editor/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;The second chapter of "&lt;a href="https://www.braveclojure.com/"&gt;Clojure for the Brave and True&lt;/a&gt;" is all about Emacs, "an excellent Clojure editor". Now you might wonder: does your choice of editor really matter that much? You're learning the language, so you don't need advanced IDE features. Some syntax highlighting, some code completion, something to help you manage all those parantheses perhaps, done. That would be true if not for the Clojure REPL.&lt;/p&gt;
&lt;h3&gt;The Clojure REPL&lt;/h3&gt;
&lt;p&gt;The &lt;a href="https://clojure.org/guides/repl/introduction"&gt;REPL&lt;/a&gt; is definitely a Thing™️ in Clojure. It gives you a prompt where you can type code and it will execute it immediately. You can also load files with code into it, interacting with the functions and data defined in those. So that's a signifcantly faster feedback loop than having to compile and then run - which is how you'd normally run something written in Clojure, since its primary platform is the JVM. There are &lt;a href="https://clojure.org/guides/repl/launching_a_basic_repl"&gt;different ways&lt;/a&gt; of launching a REPL, but most guides I found tell you to use &lt;a href="https://leiningen.org/"&gt;Leiningen&lt;/a&gt;. Oh, and REPL stands for Read-Evaluate-Print_Loop, because that's what the REPL does.&lt;/p&gt;
&lt;p&gt;It definitely feels like this REPL is a bigger deal than I appreciate right now. Probably because I have only just begun learning Clojure. On the other hand, I may have also been spoiled by the quick feedback provided by Python and its &lt;a href="https://docs.python.org/3/library/idle.html"&gt;IDLE&lt;/a&gt;. On the third hand, it's only because of learning of the Clojure REPL, I looked into importing files into Python's IDLE and found out that's indeed a thing it can do.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clojure/2020/clj1-deciding-on-an-editor/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="brave-clojure" label="brave clojure"/>
    <category term="clojure" label="clojure"/>
    <category term="ides" label="IDEs"/>
    <category term="programming" label="programming"/>
    <category term="vim" label="vim"/>
  </entry>
  <entry>
    <title>(clj 0) Diving straight in with some koans</title>
    <id>https://j19sch.github.io/blog/clojure/2020/clj0-diving-straight-in/</id>
    <updated>2020-04-27T21:00:15+02:00</updated>
    <published>2020-04-27T21:00:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clojure/2020/clj0-diving-straight-in/"/>
    <summary type="html">&lt;div&gt;&lt;h3&gt;Why Clojure?&lt;/h3&gt;
&lt;p&gt;A long time ago (meaning I don't remember when but it's been a while) I learned about a programming language called Lisp. It was said that by studying this language you'd gain &lt;a href="https://twobithistory.org/2018/10/14/lisp.html"&gt;deep insights&lt;/a&gt; into programming and you'd never write code the same way again. That definitely piqued my interest.&lt;/p&gt;
&lt;p&gt;Some time later (don't remember when exactly either) I learned about the existence of Clojure and that it too, was something special. So I added it to the list of programming languages I wanted to learn some day.&lt;/p&gt;
&lt;p&gt;Then, earlier this month, I felt the need to start a new project. To learn something new. So I figured I'd learn Lisp. That didn't last long though, as I found out that the recommended editor for Lisp is Emacs. And from trying out Emacs and vi about 20 years ago I knew that for some reason vi does fit with how my mind works, and Emacs doesn't.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clojure/2020/clj0-diving-straight-in/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="brave-clojure" label="brave clojure"/>
    <category term="clojure" label="clojure"/>
    <category term="koans" label="koans"/>
    <category term="programming" label="programming"/>
  </entry>
  <entry>
    <title>Getting [name] from "Name: [name]" in Python - an engineering problem</title>
    <id>https://j19sch.github.io/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/</id>
    <updated>2019-08-26T21:27:38+02:00</updated>
    <published>2019-08-26T21:27:38+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;Today I was presented with an interesting engineering problem. (Important later: context was the code of an auto-test.) Given a string of the format "Name: [name]", what's the best way to get the [name] in Python?&lt;/p&gt;
&lt;p&gt;There are several options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lstrip()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;string slicing&lt;/li&gt;
&lt;li&gt;regex&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So let's look at each of them and then I'll explain which one I prefer and why. All examples are in Python 3.6, using the &lt;a href="https://docs.python.org/3.6/tutorial/interpreter.html"&gt;Python Interpreter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="programming" label="programming"/>
    <category term="python" label="python"/>
    <category term="semantics" label="semantics"/>
  </entry>
  <entry>
    <title>How this tester writes code</title>
    <id>https://j19sch.github.io/blog/2019/how-this-tester-writes-code/</id>
    <updated>2019-06-08T18:21:38+02:00</updated>
    <published>2019-06-08T18:21:38+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/2019/how-this-tester-writes-code/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;A long time ago (March 2015) I wrote a post titled "&lt;a href="https://j19sch.github.io/blog/2015/test-automation-five-questions-leading-to-five-heuristics/"&gt;Test automation - five questions leading to five heuristics&lt;/a&gt;". Later that year &lt;a href="https://twitter.com/richrtesting"&gt;Rich Rogers&lt;/a&gt; asked for a follow-up. To which I replied I should do a follow-up post (ahum) "soon".
Then last Wednesday &lt;a href="https://twitter.com/noahsussman"&gt;Noah Sussman&lt;/a&gt; said on &lt;a href="https://twitter.com/noahsussman/status/1136288062651142149"&gt;twitter&lt;/a&gt;: &lt;em&gt;'I don't know that I've *ever* seen "this is how testers write code"'&lt;/em&gt;. To which I replied "challenge accepted", so now here we are, me writing a blog post about how I as a tester write code.&lt;/p&gt;
&lt;p&gt;The format of this post turned out to be advice based on my experiences, so the usual disclaimers apply. And feel free to leave a comment if you have any feedback!&lt;/p&gt;
&lt;h3&gt;The basics&lt;/h3&gt;
&lt;h4&gt;use an IDE&lt;/h4&gt;
&lt;p&gt;An IDE is not just an advanced text editor. It understands your code - to a degree, since it's not interpreting, compiling or executing the code. So not only allows an IDE you to manipulate your code as text, it also allows you to manipulate your code as code.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/2019/how-this-tester-writes-code/"&gt;Read more…&lt;/a&gt; (14 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="ides" label="IDEs"/>
    <category term="programming" label="programming"/>
    <category term="python" label="python"/>
  </entry>
  <entry>
    <title>Test automation - five questions leading to five heuristics</title>
    <id>https://j19sch.github.io/blog/2015/test-automation-five-questions-leading-to-five-heuristics/</id>
    <updated>2015-03-24T20:53:24+01:00</updated>
    <published>2015-03-24T20:53:24+01:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/2015/test-automation-five-questions-leading-to-five-heuristics/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;(I wrote a follow-up to this post in June 2019: &lt;a href="https://j19sch.github.io/blog/2019/how-this-tester-writes-code/"&gt;how this tester writes code&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;In 1984 Abelson and Sussman said in the Preface to '&lt;a href="https://mitpress.mit.edu/sicp/"&gt;Structure and Interpretation of Computer Programs&lt;/a&gt;':&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Our design of this introductory computer-science subject reflects two major concerns. First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. &lt;strong&gt;Thus, programs must be written for people to read, and only incidentally for machines to execute.&lt;/strong&gt; Second, we believe that the essential material to be addressed by a subject at this level is not the syntax of particular programming-language constructs, nor clever algorithms for computing particular functions efficiently, nor even the mathematical analysis of algorithms and the foundations of computing, but rather the techniques used to control the intellectual complexity of large software systems. [emphasis mine]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This oft-quoted sentence I emphasized, is even more true if the purpose of our programs is test automation&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="https://j19sch.github.io/blog/2015/test-automation-five-questions-leading-to-five-heuristics/#fn:1"&gt;1&lt;/a&gt;&lt;/sup&gt;. So let's say you run your test automation program and the result is a list of passes and fails.  The purpose of testing is to produce information. You could say that this list of results qualifies as information and I would disagree. I would say it is data, data in need of interpretation. When we attempt this interpretation, we should consider the following five questions.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/2015/test-automation-five-questions-leading-to-five-heuristics/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="programming" label="programming"/>
    <category term="test-automation" label="test automation"/>
    <category term="testing-and-checking" label="testing and checking"/>
  </entry>
</feed>
