<?xml version='1.0' encoding='UTF-8'?>
<?xml-stylesheet href="https://j19sch.github.io/assets/xml/atom.xsl" type="text/xsl media="all"?>
<feed xml:lang="en" xmlns="http://www.w3.org/2005/Atom">
  <title>Joep Schuurkes (Posts about clojure)</title>
  <id>https://j19sch.github.io/categories/cat_clojure.atom</id>
  <updated>2020-09-27T12:37:02Z</updated>
  <author>
    <name>Joep Schuurkes</name>
  </author>
  <link rel="self" type="application/atom+xml" href="https://j19sch.github.io/categories/cat_clojure.atom"/>
  <link rel="alternate" type="text/html" href="https://j19sch.github.io/categories/cat_clojure/"/>
  <generator uri="https://getnikola.com/">Nikola</generator>
  <entry>
    <title>(clj 4) Learning about when, maps and closures</title>
    <id>https://j19sch.github.io/blog/clj4-learning-when-maps-closures/</id>
    <updated>2020-07-31T22:25:15+02:00</updated>
    <published>2020-07-31T22:25:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clj4-learning-when-maps-closures/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;It's been more than two months since I did any Clojure - for the obvious reasons. Luckily I did take notes as I proceeded with chapter 3 of "&lt;a href="https://www.braveclojure.com/"&gt;Clojure for the Brave and True&lt;/a&gt;". So the plan is to process these notes into a blog post, which means this post will cover the sections "Data Structures" and "Functions" of that third chapter. Leaving me ready to proceed with the rest of the chapter, i.e. "Pulling It All Together" and the summary and exercises.&lt;/p&gt;
&lt;h3&gt;Why is there a &lt;code&gt;when&lt;/code&gt;?&lt;/h3&gt;
&lt;p&gt;The part about control flow is actually before the part about &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; which I talked about in my &lt;a href="https://j19sch.github.io/blog/clj3-and-or-being-weird"&gt;previous post&lt;/a&gt;, but according to my notes I returned to it. I don't remember why to be honest.&lt;/p&gt;
&lt;p&gt;The book provides the following example of &lt;code&gt;when&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"Success!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;"abra cadabra"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; Success!&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; "abra cadabra"&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;And if the condition is &lt;code&gt;false&lt;/code&gt;, you get:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;when &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"First do!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="s"&gt;"By Odin's Elbow!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;So &lt;code&gt;when&lt;/code&gt; allows you to do several things and return something when the condition is &lt;code&gt;true&lt;/code&gt;, while it will return &lt;code&gt;nil&lt;/code&gt; if the condition is &lt;code&gt;false&lt;/code&gt;. The thing that got me curious is that you can do the same thing almost as easily with &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;do&lt;/code&gt;:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;true&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"Success!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="s"&gt;"abra cadabra"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; Success!&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; "abra cadabra"&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;if &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;
  &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;do &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;println &lt;/span&gt;&lt;span class="s"&gt;"First do!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
      &lt;span class="s"&gt;"By Odin's Elbow!"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;I can see two advantages to having the &lt;code&gt;when&lt;/code&gt;. It needs fewer characters: two brackets and a space. It's also more readable, since there is no &lt;code&gt;do&lt;/code&gt; and no indentation decisions because of that &lt;code&gt;do&lt;/code&gt;. Is that enough reason? I honestly don't know, because I haven't written enough Clojure to decide if you use &lt;code&gt;when&lt;/code&gt; often enough to make it worth it having it.&lt;/p&gt;
&lt;p&gt;There is another difference, however, which I found out thanks to &lt;a href="https://github.com/tpope/vim-fireplace"&gt;vim-fireplace&lt;/a&gt;'s &lt;code&gt;K&lt;/code&gt; command, which looks up the symbol under the cursor with &lt;code&gt;doc&lt;/code&gt;. &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;do&lt;/code&gt; are Special Forms, while &lt;code&gt;when&lt;/code&gt; is a Macro. What difference that makes, I don't know yet. In the section about functions in the same chapter, it does say on page 126:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You’ll learn everything there is to know about macro calls and special forms in Chapter 7. For now, the main feature that makes special forms “special” is that, unlike function calls, they don’t always evaluate all of their operands.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And on page 127:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Macros are similar to special forms in that they evaluate their operands differently from function calls, and they also can’t be passed as arguments to functions.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I made a note to revisit this when I get to Chapter 7. So one day there should be a link to that post here.&lt;/p&gt;
&lt;h3&gt;Maps&lt;/h3&gt;
&lt;p&gt;With my Python background I had some trouble with the syntax of maps. With keywords being used as keys, they look like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:first-name&lt;/span&gt; &lt;span class="s"&gt;"Charlie"&lt;/span&gt;
 &lt;span class="ss"&gt;:last-name&lt;/span&gt; &lt;span class="s"&gt;"McFishwich"&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;So the same characters as a Python dictionary but in a different order. This made me appreciate the value of practice. I won't be enjoying writing Clojure if I mess up the syntax of maps every time because of Python muscle memory.&lt;/p&gt;
&lt;p&gt;Practice wasn't without its hurdles, though. When I defined a map and evaluated it like this:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;my-other-map&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;hash-map &lt;/span&gt;&lt;span class="ss"&gt;:a&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="ss"&gt;:b&lt;/span&gt; &lt;span class="mi"&gt;101&lt;/span&gt; &lt;span class="ss"&gt;:c&lt;/span&gt; &lt;span class="mi"&gt;102&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;my-other-map&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;I got the error &lt;code&gt;ArityException Wrong number of args (0) passed to: PersistentArrayMap  clojure.lang.AFn.throwArity (AFn.java:429)&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;Removing ther parantheses around the map's name resulted in:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;Error detected while processing function &amp;lt;SNR&amp;gt;48_printop[1]..&amp;lt;SNR&amp;gt;48_opfunc[40]..function &amp;lt;SNR&amp;gt;48_printop[1]..&amp;lt;SNR&amp;gt;48_opfunc:
line   21:
E20: Mark not set
E20: Mark not set
Press ENTER or type command to continue
&lt;/pre&gt;


&lt;p&gt;The solution turned out to be to not have the parantheses (so just &lt;code&gt;my-other-map&lt;/code&gt; on its own line), but then not use &lt;code&gt;cpp&lt;/code&gt; to evaluate the statement, which evaluates the innermost statement, but use &lt;code&gt;cp$&lt;/code&gt; (evaluate until end of the line) or &lt;code&gt;cp_&lt;/code&gt; (evaluate current line).&lt;/p&gt;
&lt;p&gt;Trying to evaluate the innermost form of a string in parantheses, gave me an impressive error message as well:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;ClassCastException class java.lang.String cannot be cast to class clojure.lang.IFn (java.lang.String is in module java.base of loader 'bootstrap'; clojure.lang.IFn is in unnamed module of loader 'app')  clojure-noob.core/eval6974 (form-init11099437324952859876.clj:5)
&lt;/pre&gt;


&lt;p&gt;My notes tell me I didn't understand what exactly was going on here. Today, while writing this blog post, I went back in the book to the start of the chapter and there it explains that Clojure recognizes two kinds of structures: literal representations of data structures and operations. All operations take the form of opening parenthesis, operator, operands, closing parenthesis. Me putting the name of my hash map or a string literal in parantheses is neither of those structures, so makes sense I get an error.&lt;/p&gt;
&lt;p&gt;Then for the scope of evaluation, &lt;code&gt;cpp&lt;/code&gt; evaluates the innermost form. However I am on a line with just the name of my map, so I'm not sure what it tries to evaluate. Perhaps the whole file? In any case it's not what I want to evaluate, so it's ok that it throws an error instead of working.&lt;/p&gt;
&lt;p&gt;Finally, I was surprised that all these three ways to get a value from a map are part of the language:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;def &lt;/span&gt;&lt;span class="nv"&gt;my-map&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:a&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ss"&gt;:b&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="ss"&gt;:c&lt;/span&gt; &lt;span class="s"&gt;"ho hum"&lt;/span&gt;&lt;span class="p"&gt;}})&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;get &lt;/span&gt;&lt;span class="nv"&gt;my-map&lt;/span&gt; &lt;span class="ss"&gt;:a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; 0&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;my-map&lt;/span&gt; &lt;span class="ss"&gt;:a&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; 0&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="ss"&gt;:a&lt;/span&gt; &lt;span class="nv"&gt;my-map&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; 0&lt;/span&gt;
&lt;/pre&gt;


&lt;h3&gt;Functions and returning functions&lt;/h3&gt;
&lt;p&gt;The section about functions ends with the following explanation about returning functions:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;By now you’ve seen that functions can return other functions. The returned functions are &lt;em&gt;closures&lt;/em&gt;, which means that they can access all the variables that were in scope when the function was created. Here’s a standard example:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;defn&lt;/span&gt; &lt;span class="nv"&gt;inc-maker&lt;/span&gt;
  &lt;span class="s"&gt;"Create a custom incrementor"&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;inc-by&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;#&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;+&lt;/span&gt; &lt;span class="nv"&gt;%&lt;/span&gt; &lt;span class="nv"&gt;inc-by&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;


&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;def&lt;/span&gt; &lt;span class="nv"&gt;inc3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;inc-maker&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;inc3&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; 10&lt;/span&gt;
&lt;/pre&gt;


&lt;blockquote&gt;
&lt;p&gt;Here, &lt;code&gt;inc-by&lt;/code&gt; is in scope, so the returned function has access to it even when the returned function is used outside &lt;code&gt;inc-maker&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;I do not understand this explanation. In my mind the &lt;code&gt;inc-maker&lt;/code&gt; returns a function that adds 3 to a number, so basically &lt;code&gt;(defn inc3 [number] (+ number 3))&lt;/code&gt;, and I don't see how the scope of &lt;code&gt;inc-by&lt;/code&gt; comes into play. (I am noticing now though that in the example &lt;code&gt;def&lt;/code&gt; is used, not &lt;code&gt;defn&lt;/code&gt; to create the &lt;code&gt;inc3&lt;/code&gt; function.) So now I have some code that does make sense to me, while the explanation of the code doesn't, which is a somewhat weird place to be in.&lt;/p&gt;
&lt;p&gt;In the hope of figuring this out I checked Wikipedia which says about &lt;a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)"&gt;clojures&lt;/a&gt;: "Operationally, a closure is a record storing a function together with an environment." Which is in line with the explanation quoted above, but it doesn't help me understand.&lt;/p&gt;
&lt;p&gt;It doesn't help either that the name of this language, Clojure, is a pun on the term 'closure', which makes me feel it is important to understand them. Some more searching didn't get me anything useful, although I did find &lt;a href="https://groups.google.com/forum/#!msg/clojure/4uDxeOS8pwY/UHiYp7p1a3YJ"&gt;this post&lt;/a&gt; from &lt;a href="https://twitter.com/richhickey"&gt;Rich Hickey&lt;/a&gt; about naming Clojure "Clojure":&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The name was chosen to be unique. I wanted to involve c (c#), l (lisp)
and j (java).&lt;/p&gt;
&lt;p&gt;Once I came up with Clojure, given the pun on closure, the available
domains and vast emptiness of the googlespace, it was an easy
decision.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;And that's where I decided to accept I would not be understanding why closures are important when functions return other functions. Except that after writing the previous sentence, I started wondering if I could construct a more complicated function that returns a function, that would help me understand. I failed to construct such a function, since it wouldn't accept me binding a variable in either of the ways I tried to.&lt;/p&gt;
&lt;p&gt;In any case, hopefully I will understand this one day. It does leave me with the feeling that the explanation about closures doesn't need to be in this part of the book. Perhaps it would be more in its place in chapter 7 which describes how Clojure runs your code.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;As I did in my previous post, this postscript contains some smaller things I noticed and/or learned.&lt;/p&gt;
&lt;h4&gt;Notes on blogging&lt;/h4&gt;
&lt;p&gt;Thanks to the combination of my notes, my play-around files and some re-playing around, it was fairly easy to write this blog post. I don't like leaving such a gap between learning and blogging, but it's good to know that when it happens, it's not a problem.&lt;/p&gt;
&lt;h4&gt;Notes on Vim&lt;/h4&gt;
&lt;p&gt;I had to relearn a few things. Vim-fireplace will not connect to the REPL if you don't start one with &lt;code&gt;lein repl&lt;/code&gt; first. Use &lt;code&gt;"+&lt;/code&gt; in Vim to copy-paste to the system clipboard (thank you past me for the &lt;a href="https://j19sch.github.io/blog/clj4-learning-when-maps-closures/(/my-projects/clojure-vim-cheatsheet)"&gt;cheatsheet&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Changing to gruvbox as Vim theme was a good idea. I did have to move the colorscheme line in my &lt;code&gt;.vimrc&lt;/code&gt; because the statusbar was not green in normal mode.&lt;/p&gt;
&lt;p&gt;In my previous post's postscrpit I was wondering how to get the result of an evaluation into my file. I have found a way, but it's quite a few keystrokes: copy the thing, paste the thing, evaluate it with &lt;code&gt;c!{motion}&lt;/code&gt; which replaces it with the result of the evaluation, then &lt;code&gt;gcc&lt;/code&gt; to make it into a comment. I might need to make a custom vim command to make that easier.&lt;/p&gt;
&lt;p&gt;According to my notes I used &lt;code&gt;ctrl+n&lt;/code&gt; (next match) and &lt;code&gt;ctrl+p&lt;/code&gt; (previous match) for auto-completion, so I added those to my cheatsheet.&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="brave-true" label="brave-true"/>
    <category term="clojure" label="clojure"/>
    <category term="closures" label="closures"/>
    <category term="maps" label="maps"/>
    <category term="when" label="when"/>
  </entry>
  <entry>
    <title>(clj 3) Clojure's 'and' and 'or' are weird (but not really)</title>
    <id>https://j19sch.github.io/blog/clj3-and-or-being-weird/</id>
    <updated>2020-05-16T21:25:15+02:00</updated>
    <published>2020-05-16T21:25:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clj3-and-or-being-weird/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;Early in &lt;a href="https://www.braveclojure.com/do-things/#Control_Flow"&gt;chapter 3&lt;/a&gt; of the &lt;a href="https://www.braveclojure.com/"&gt;Brave and True&lt;/a&gt;-book the Boolean operators &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; are introduced:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Clojure uses the Boolean operators &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;. &lt;code&gt;or&lt;/code&gt; returns either the first truthy value or the last value. &lt;code&gt;and&lt;/code&gt; returns the first falsey value or, if no values are falsey, the last truthy value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This explanation is followed by some examples:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;false&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt; &lt;span class="ss"&gt;:large_I_mean_venti&lt;/span&gt; &lt;span class="ss"&gt;:why_cant_I_just_say_large&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; :large_I_mean_venti&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt; &lt;span class="s"&gt;"yes"&lt;/span&gt; &lt;span class="s"&gt;"no"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; false&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;


&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;and&lt;/span&gt; &lt;span class="ss"&gt;:free_wifi&lt;/span&gt; &lt;span class="ss"&gt;:hot_coffee&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; :hot_coffee&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;and&lt;/span&gt; &lt;span class="ss"&gt;:feelin_super_cool&lt;/span&gt; &lt;span class="nv"&gt;nil&lt;/span&gt; &lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;What I found remarkable about this is that &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; do not return a boolean in all cases. Before I go into that, let's back up a second and cover their basics in a little more depth first.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clj3-and-or-being-weird/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="booleans" label="booleans"/>
    <category term="brave-true" label="brave-true"/>
    <category term="clojure" label="clojure"/>
  </entry>
  <entry>
    <title>(clj 2) Setting up Vim for Clojure</title>
    <id>https://j19sch.github.io/blog/clj2-setting-up-vim/</id>
    <updated>2020-05-05T21:55:15+02:00</updated>
    <published>2020-05-05T21:55:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clj2-setting-up-vim/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;As mentioned in my &lt;a href="https://j19sch.github.io/blog/clj1-deciding-on-an-editor"&gt;previous post&lt;/a&gt; I've decided to use &lt;a href="https://www.vim.org/"&gt;Vim&lt;/a&gt; as my Clojure editor. That leaves me with three things to do: getting reacquainted with Vim, updating my Vim config in the .&lt;code&gt;vimrc&lt;/code&gt; file, and installing both general and Clojure-specific Vim plugins.&lt;/p&gt;
&lt;h3&gt;Getting reacquainted with Vim&lt;/h3&gt;
&lt;p&gt;Ever since I learned Vim basics a long time ago I have been using it once in a while to make small edits to a config file or a commit message, but not for anything more complicated than that. So that's the first thing I wanted to address: refresh my basics and make sure I know where to find more information when I need it.&lt;/p&gt;
&lt;h4&gt;Vimtutor&lt;/h4&gt;
&lt;p&gt;I figured that a good way to get back into Vim was the &lt;a href="https://vimhelp.org/usr_01.txt.html#vimtutor"&gt;Vimtutor&lt;/a&gt;. It's a 30-minute interactive tutorial where you edit a file with instructions with vim. I kept notes of what it covers, which you can find &lt;a href="https://j19sch.github.io/my-projects/vimtutor"&gt;here&lt;/a&gt;. Vim's help also includes a &lt;a href="https://vimhelp.org/quickref.txt.html"&gt;quickref&lt;/a&gt;, an "Overview of the most common commands you will use", which is intimidatingly long considering that description. As a reference to look things up in, it should be useful, though.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clj2-setting-up-vim/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="clojure" label="clojure"/>
    <category term="vim" label="vim"/>
  </entry>
  <entry>
    <title>(clj 1) Deciding on a Clojure editor</title>
    <id>https://j19sch.github.io/blog/clj1-deciding-on-an-editor/</id>
    <updated>2020-05-01T18:00:15+02:00</updated>
    <published>2020-05-01T18:00:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clj1-deciding-on-an-editor/"/>
    <summary type="html">&lt;div&gt;&lt;p&gt;The second chapter of "&lt;a href="https://www.braveclojure.com/"&gt;Clojure for the Brave and True&lt;/a&gt;" is all about Emacs, "an excellent Clojure editor". Now you might wonder: does your choice of editor really matter that much? You're learning the language, so you don't need advanced IDE features. Some syntax highlighting, some code completion, something to help you manage all those parantheses perhaps, done. That would be true if not for the Clojure REPL.&lt;/p&gt;
&lt;h3&gt;The Clojure REPL&lt;/h3&gt;
&lt;p&gt;The &lt;a href="https://clojure.org/guides/repl/introduction"&gt;REPL&lt;/a&gt; is definitely a Thing™️ in Clojure. It gives you a prompt where you can type code and it will execute it immediately. You can also load files with code into it, interacting with the functions and data defined in those. So that's a signifcantly faster feedback loop than having to compile and then run - which is how you'd normally run something written in Clojure, since its primary platform is the JVM. There are &lt;a href="https://clojure.org/guides/repl/launching_a_basic_repl"&gt;different ways&lt;/a&gt; of launching a REPL, but most guides I found tell you to use &lt;a href="https://leiningen.org/"&gt;Leiningen&lt;/a&gt;. Oh, and REPL stands for Read-Evaluate-Print_Loop, because that's what the REPL does.&lt;/p&gt;
&lt;p&gt;It definitely feels like this REPL is a bigger deal than I appreciate right now. Probably because I have only just begun learning Clojure. On the other hand, I may have also been spoiled by the quick feedback provided by Python and its &lt;a href="https://docs.python.org/3/library/idle.html"&gt;IDLE&lt;/a&gt;. On the third hand, it's only because of learning of the Clojure REPL, I looked into importing files into Python's IDLE and found out that's indeed a thing it can do.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clj1-deciding-on-an-editor/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="clojure" label="clojure"/>
    <category term="emacs" label="emacs"/>
    <category term="vim" label="vim"/>
    <category term="vscode" label="vscode"/>
  </entry>
  <entry>
    <title>(clj 0) Diving straight in with some koans</title>
    <id>https://j19sch.github.io/blog/clj0-diving-straight-in/</id>
    <updated>2020-04-27T21:00:15+02:00</updated>
    <published>2020-04-27T21:00:15+02:00</published>
    <author>
      <name>Joep Schuurkes</name>
    </author>
    <link rel="alternate" type="text/html" href="https://j19sch.github.io/blog/clj0-diving-straight-in/"/>
    <summary type="html">&lt;div&gt;&lt;h3&gt;Why Clojure?&lt;/h3&gt;
&lt;p&gt;A long time ago (meaning I don't remember when but it's been a while) I learned about a programming language called Lisp. It was said that by studying this language you'd gain &lt;a href="https://twobithistory.org/2018/10/14/lisp.html"&gt;deep insights&lt;/a&gt; into programming and you'd never write code the same way again. That definitely piqued my interest.&lt;/p&gt;
&lt;p&gt;Some time later (don't remember when exactly either) I learned about the existence of Clojure and that it too, was something special. So I added it to the list of programming languages I wanted to learn some day.&lt;/p&gt;
&lt;p&gt;Then, earlier this month, I felt the need to start a new project. To learn something new. So I figured I'd learn Lisp. That didn't last long though, as I found out that the recommended editor for Lisp is Emacs. And from trying out Emacs and vi about 20 years ago I knew that for some reason vi does fit with how my mind works, and Emacs doesn't.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/clj0-diving-straight-in/"&gt;Read more…&lt;/a&gt; (1 min remaining to read)&lt;/p&gt;&lt;/div&gt;</summary>
    <category term="brave-true" label="brave-true"/>
    <category term="clojure" label="clojure"/>
    <category term="koans" label="koans"/>
  </entry>
</feed>
