<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Joep Schuurkes (Posts about python)</title><link>https://j19sch.github.io/</link><description></description><atom:link href="https://j19sch.github.io/categories/python.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2021 &lt;a href="mailto:j19sch@hey.com"&gt;Joep Schuurkes&lt;/a&gt; 
&lt;a href="http://creativecommons.org/licenses/by/4.0/"&gt;
&lt;img alt="Creative Commons License" style="border-width:0;margin: 0px 0px 0px 0px" src="https://i.creativecommons.org/l/by/4.0/80x15.png" /&gt;
&lt;/a&gt;
</copyright><lastBuildDate>Sun, 09 May 2021 09:04:02 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Getting [name] from "Name: [name]" in Python - an engineering problem</title><link>https://j19sch.github.io/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;Today I was presented with an interesting engineering problem. (Important later: context was the code of an auto-test.) Given a string of the format "Name: [name]", what's the best way to get the [name] in Python?&lt;/p&gt;
&lt;p&gt;There are several options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lstrip()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;string slicing&lt;/li&gt;
&lt;li&gt;regex&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So let's look at each of them and then I'll explain which one I prefer and why. All examples are in Python 3.6, using the &lt;a href="https://docs.python.org/3.6/tutorial/interpreter.html"&gt;Python Interpreter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>programming</category><category>python</category><category>semantics</category><guid>https://j19sch.github.io/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/</guid><pubDate>Mon, 26 Aug 2019 19:27:38 GMT</pubDate></item><item><title>How this tester writes code</title><link>https://j19sch.github.io/blog/2019/how-this-tester-writes-code/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;A long time ago (March 2015) I wrote a post titled "&lt;a href="https://j19sch.github.io/blog/2015/test-automation-five-questions-leading-to-five-heuristics/"&gt;Test automation - five questions leading to five heuristics&lt;/a&gt;". Later that year &lt;a href="https://twitter.com/richrtesting"&gt;Rich Rogers&lt;/a&gt; asked for a follow-up. To which I replied I should do a follow-up post (ahum) "soon".
Then last Wednesday &lt;a href="https://twitter.com/noahsussman"&gt;Noah Sussman&lt;/a&gt; said on &lt;a href="https://twitter.com/noahsussman/status/1136288062651142149"&gt;twitter&lt;/a&gt;: &lt;em&gt;'I don't know that I've *ever* seen "this is how testers write code"'&lt;/em&gt;. To which I replied "challenge accepted", so now here we are, me writing a blog post about how I as a tester write code.&lt;/p&gt;
&lt;p&gt;The format of this post turned out to be advice based on my experiences, so the usual disclaimers apply. And feel free to leave a comment if you have any feedback!&lt;/p&gt;
&lt;h3&gt;The basics&lt;/h3&gt;
&lt;h4&gt;use an IDE&lt;/h4&gt;
&lt;p&gt;An IDE is not just an advanced text editor. It understands your code - to a degree, since it's not interpreting, compiling or executing the code. So not only allows an IDE you to manipulate your code as text, it also allows you to manipulate your code as code.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/2019/how-this-tester-writes-code/"&gt;Read more…&lt;/a&gt; (14 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>IDEs</category><category>programming</category><category>python</category><guid>https://j19sch.github.io/blog/2019/how-this-tester-writes-code/</guid><pubDate>Sat, 08 Jun 2019 16:21:38 GMT</pubDate></item><item><title>Solving Black Box Puzzle 31 with data analysis</title><link>https://j19sch.github.io/blog/2019/solving-black-box-puzzle-31-with-data-analysis/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://twitter.com/workroomprds"&gt;James Lyndsay&lt;/a&gt; has created a number of amazing &lt;a href="http://blackboxpuzzles.workroomprds.com/"&gt;Black Box Puzzles&lt;/a&gt;: tiny applications that challenge you to figure out what they do. (You can support him in creating more of these at &lt;a href="https://www.patreon.com/workroomprds"&gt;his Patreon page&lt;/a&gt;.) Two of these Puzzles, &lt;a href="http://blackboxpuzzles.workroomprds.com/puzzle29/"&gt;29&lt;/a&gt; and &lt;a href="http://blackboxpuzzles.workroomprds.com/puzzle31/"&gt;31&lt;/a&gt;, not only have a GUI to explore, but also an API.&lt;/p&gt;
&lt;p&gt;And that gave me an idea. If you explore these Puzzles through their GUI, you start from the inputs. You try out different inputs in the hope of discovering a pattern in the outputs. And then that pattern feeds back into your exploration.&lt;br&gt;
With an API, however - and because of the nature of Puzzle 31 - it becomes easy to get the outputs for all possible combinations of inputs. Which means you can start your exploration from the outputs instead of the inputs.&lt;/p&gt;
&lt;p&gt;Before I tell you how and what I did, three important remarks.&lt;br&gt;
First of all, I will be spoiling the solution to the Puzzle in this blog post. So this is the right moment to go and solve &lt;a href="http://blackboxpuzzles.workroomprds.com/puzzle31/"&gt;Puzzle 31&lt;/a&gt; for yourself first. Or at least go play a bit with it, so you have an idea what the inputs and outputs are.&lt;br&gt;
Secondly, I had already solved the Puzzle through the GUI a few months ago. So it was more of a "Can I find the solution this way as well?" than a "Can I find the solution?" thing.&lt;br&gt;
Finally, the code and the spreadsheet I created (linked throughout, also available on GitHub &lt;a href="https://github.com/j19sch/blackbox-puzzle-31"&gt;here&lt;/a&gt;), are not very clean. I thought about tidying them up, but my two reasons for not doing so are (1) laziness; (2) the way they are now gives a more honest picture of what I did.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://j19sch.github.io/blog/2019/solving-black-box-puzzle-31-with-data-analysis/"&gt;Read more…&lt;/a&gt; (18 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>automation</category><category>black box puzzle</category><category>data analysis</category><category>exploration</category><category>python</category><guid>https://j19sch.github.io/blog/2019/solving-black-box-puzzle-31-with-data-analysis/</guid><pubDate>Sun, 28 Apr 2019 11:16:34 GMT</pubDate></item></channel></rss>