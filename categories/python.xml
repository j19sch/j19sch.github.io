<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Joep Schuurkes (Posts about python)</title><link>https://smallsheds.garden/</link><description></description><atom:link href="https://smallsheds.garden/categories/python.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2024 &lt;a href="mailto:site@joep.slmail.me"&gt;Joep Schuurkes&lt;/a&gt; 
&lt;a href="https://creativecommons.org/licenses/by/4.0/" rel="nofollow" target="_blank"&gt;
&lt;img alt="Creative Commons License" style="border-width:0;margin: 0px 0px 0px 0px" src="https://licensebuttons.net/l/by/4.0/80x15.png" /&gt;
&lt;/a&gt;
</copyright><lastBuildDate>Mon, 27 May 2024 18:45:48 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>A lesson from every language I've used</title><link>https://smallsheds.garden/blog/2023/a-lesson-from-every-language-ive-used/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;Throughout the years I've used quite a few different languages - if you allow me to be somewhat generous with the word "use". One language I actually feel proficient in. Some languages I've only done coding exercises in. And one language I've only used for a total of maybe 10 minutes, but that did really help out a whole team.&lt;/p&gt;
&lt;p&gt;I do believe we should be that generous, both towards ourselves and to others. For an industry that likes to talk about imposter syndrome, we seem to enjoy saying &lt;em&gt;"You're not a real ... unless..."&lt;/em&gt; a bit too much.&lt;/p&gt;
&lt;p&gt;Listing these languages for myself made me wonder what I had learned from them. Did I just learn how to write some code in each of them? Or did I also pick up some more general lessons? Turns out I did.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/2023/a-lesson-from-every-language-ive-used/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>clojure</category><category>programming</category><category>python</category><guid>https://smallsheds.garden/blog/2023/a-lesson-from-every-language-ive-used/</guid><pubDate>Thu, 28 Dec 2023 23:00:00 GMT</pubDate></item><item><title>(clj 9) How to figure out what a function does</title><link>https://smallsheds.garden/blog/clojure/2022/clj-9-how-to-figure-out-what-a-function-does/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;Chapter 4 of "&lt;a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/"&gt;Clojure for the Brave and True&lt;/a&gt;" concludes with a &lt;em&gt;Vampire Data Analysis Program&lt;/em&gt;, serving as a summary of the chapter. The book shows some code, explains it, moves on to the next bit of code, etc. I'm not sure why, but I decided I wanted to figure out the code on my own and then read the explanation to see if I got it right. Afterwards I realized it might make a good blog post: both explaining what the program does and what techniques (for lack of a better word) I used to figure it out.&lt;/p&gt;
&lt;p&gt;With most of the work in the program being done by a function called &lt;code&gt;mapify&lt;/code&gt;, this blog post will focus on that single function. As it turns out, it took me more than 2000 words (footnotes not included) to describe what this function consisting of only 9 lines does. So feel free to read all of it, skim through it, or skip straight ahead to the &lt;a href="https://smallsheds.garden/blog/clojure/2022/clj-9-how-to-figure-out-what-a-function-does/#techniques"&gt;techniques&lt;/a&gt; and some &lt;a href="https://smallsheds.garden/blog/clojure/2022/clj-9-how-to-figure-out-what-a-function-does/#reflections"&gt;reflections&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/clojure/2022/clj-9-how-to-figure-out-what-a-function-does/"&gt;Read more…&lt;/a&gt; (16 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>brave clojure</category><category>clojure</category><category>programming</category><category>python</category><guid>https://smallsheds.garden/blog/clojure/2022/clj-9-how-to-figure-out-what-a-function-does/</guid><pubDate>Sun, 12 Jun 2022 13:01:36 GMT</pubDate></item><item><title>(clj 8) Some notes on lazy sequences and function parameters</title><link>https://smallsheds.garden/blog/clojure/2022/clj-8-some-notes-on-lazy-sequences-and-function-parameters/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;Almost done with the chapter 4 &lt;em&gt;"Core Functions in Depth"&lt;/em&gt; of "&lt;a href="https://www.braveclojure.com/clojure-for-the-brave-and-true/"&gt;Clojure for the Brave and True&lt;/a&gt;"! Before wrapping up the chapter with a longer example, a summary, and some exercises, the book goes into lazy sequences, the collection abstraction, and function functions. In this post I will share some notes on infinite lazy sequences and function parameters, making comparisons between Clojure and Python.&lt;/p&gt;
&lt;h2&gt;Infinite lazy sequences&lt;/h2&gt;
&lt;p&gt;A lazy sequence is a sequence whose members aren't computed until you try to access them. One advantage is that it's more efficient: the whole sequence doesn't have to be calculated and kept in memory from the start. Another advantage is that it allows you to create infinite sequences. Do that with a normal sequence and your program would never want to stop calculating.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/clojure/2022/clj-8-some-notes-on-lazy-sequences-and-function-parameters/"&gt;Read more…&lt;/a&gt; (4 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>brave clojure</category><category>clojure</category><category>programming</category><category>python</category><guid>https://smallsheds.garden/blog/clojure/2022/clj-8-some-notes-on-lazy-sequences-and-function-parameters/</guid><pubDate>Mon, 18 Apr 2022 12:16:36 GMT</pubDate></item><item><title>(clj 7) Programming to abstractions with sequence functions</title><link>https://smallsheds.garden/blog/clojure/2021/clj7-programming-to-abstractions-with-sequence-functions/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;Looking at my progress so far, I realized it's time re-evaluate this whole learning Clojure-thing. After looking through the table of contents of "&lt;a href="https://www.braveclojure.com/"&gt;Clojure for the Brave and True&lt;/a&gt;" and giving it some thought, I decided to make two changes to how I'll proceed:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I will start writing shorter posts and write them more often.&lt;/li&gt;
&lt;li&gt;My goal is to finish &lt;em&gt;"Part II: Language Fundamentals"&lt;/em&gt;. I don't have to do &lt;em&gt;"Part III: Advanced Topics"&lt;/em&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Completing Part II will still take quite some work. I've worked through the two first sections of chapter 4 (5 sections left in that chapter) and Part II goes up to chapter 8. So no time to waste: let's take a look at sequence functions and programming to abstractions.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/clojure/2021/clj7-programming-to-abstractions-with-sequence-functions/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>brave clojure</category><category>clojure</category><category>programming</category><category>python</category><guid>https://smallsheds.garden/blog/clojure/2021/clj7-programming-to-abstractions-with-sequence-functions/</guid><pubDate>Sun, 05 Dec 2021 12:40:36 GMT</pubDate></item><item><title>(clj 5) Loop and recur, into and conj</title><link>https://smallsheds.garden/blog/clojure/2020/clj5-loop-and-recur-into-and-conj/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;Yet again it's been a while since I did some Clojure or blogged about it. This time I'm writing this blog post
three months after working on the code on September 5, 6 and 12. I'm not going to dwell on that too long, because
other things in my life were more important. I did feel a little sad when this year's &lt;a href="https://adventofcode.com/"&gt;Advent of Code&lt;/a&gt;
launched and I realized my Clojure is nowhere near a state where I could attempt the puzzles. So I ended up doing
the first 10 days in Python, which is twice as far as I got last year.&lt;/p&gt;
&lt;p&gt;I also feel like my current approach to learning lends itself well enough to going slow. Taking my time to play around
and make notes with while working through a section of &lt;a href="https://www.braveclojure.com/"&gt;Clojure for the Brave and True&lt;/a&gt;
and then revisiting my code and notes later to write a blog post, does seem to result in stuff actually sticking in my memory.
(Disclaimer: am writing this before writing the rest of this blog post.) Slow is smooth and smooth is fast, as they say.&lt;/p&gt;
&lt;p&gt;The section I tackled in September is "Pulling It All Together" from Chapter 3, which describes the construction of a 
piece of code of about 50 lines in which - I'm sorry to say -  a hobbit gets hit in different body parts.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/clojure/2020/clj5-loop-and-recur-into-and-conj/"&gt;Read more…&lt;/a&gt; (6 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>brave clojure</category><category>clojure</category><category>programming</category><category>python</category><guid>https://smallsheds.garden/blog/clojure/2020/clj5-loop-and-recur-into-and-conj/</guid><pubDate>Sat, 26 Dec 2020 09:09:08 GMT</pubDate></item><item><title>(clj 3) Clojure's 'and' and 'or' are weird (but not really)</title><link>https://smallsheds.garden/blog/clojure/2020/clj3-and-or-being-weird/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;Early in &lt;a href="https://www.braveclojure.com/do-things/#Control_Flow"&gt;chapter 3&lt;/a&gt; of the &lt;a href="https://www.braveclojure.com/"&gt;Brave and True&lt;/a&gt;-book the Boolean operators &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; are introduced:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Clojure uses the Boolean operators &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;. &lt;code&gt;or&lt;/code&gt; returns either the first truthy value or the last value. &lt;code&gt;and&lt;/code&gt; returns the first falsey value or, if no values are falsey, the last truthy value.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This explanation is followed by some examples:&lt;/p&gt;
&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:large_I_mean_venti&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:why_cant_I_just_say_large&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; :large_I_mean_venti&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"yes"&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;"no"&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; false&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;or&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="code"&gt;&lt;pre class="code literal-block"&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:free_wifi&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:hot_coffee&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; :hot_coffee&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="ss"&gt;:feelin_super_cool&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;nil&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nv"&gt;false&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="c1"&gt;; =&amp;gt; nil&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What I found remarkable about this is that &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; do not return a boolean in all cases. Before I go into that, let's back up a second and cover their basics in a little more depth first.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/clojure/2020/clj3-and-or-being-weird/"&gt;Read more…&lt;/a&gt; (7 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>brave clojure</category><category>clojure</category><category>programming</category><category>python</category><guid>https://smallsheds.garden/blog/clojure/2020/clj3-and-or-being-weird/</guid><pubDate>Sat, 16 May 2020 19:25:15 GMT</pubDate></item><item><title>Getting [name] from "Name: [name]" in Python - an engineering problem</title><link>https://smallsheds.garden/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;Today I was presented with an interesting engineering problem. (Important later: context was the code of an auto-test.) Given a string of the format "Name: [name]", what's the best way to get the [name] in Python?&lt;/p&gt;
&lt;p&gt;There are several options:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lstrip()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;split()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replace()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;string slicing&lt;/li&gt;
&lt;li&gt;regex&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So let's look at each of them and then I'll explain which one I prefer and why. All examples are in Python 3.6, using the &lt;a href="https://docs.python.org/3.6/tutorial/interpreter.html"&gt;Python Interpreter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/"&gt;Read more…&lt;/a&gt; (5 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>programming</category><category>python</category><category>semantics</category><guid>https://smallsheds.garden/blog/2019/getting-name-from-name-name-in-python-an-engineering-problem/</guid><pubDate>Mon, 26 Aug 2019 19:27:38 GMT</pubDate></item><item><title>How this tester writes code</title><link>https://smallsheds.garden/blog/2019/how-this-tester-writes-code/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;A long time ago (March 2015) I wrote a post titled "&lt;a href="https://smallsheds.garden/blog/2015/test-automation-five-questions-leading-to-five-heuristics/"&gt;Test automation - five questions leading to five heuristics&lt;/a&gt;". Later that year &lt;a href="https://twitter.com/richrtesting"&gt;Rich Rogers&lt;/a&gt; asked for a follow-up. To which I replied I should do a follow-up post (ahum) "soon".
Then last Wednesday &lt;a href="https://twitter.com/noahsussman"&gt;Noah Sussman&lt;/a&gt; said on &lt;a href="https://twitter.com/noahsussman/status/1136288062651142149"&gt;twitter&lt;/a&gt;: &lt;em&gt;'I don't know that I've *ever* seen "this is how testers write code"'&lt;/em&gt;. To which I replied "challenge accepted", so now here we are, me writing a blog post about how I as a tester write code.&lt;/p&gt;
&lt;p&gt;The format of this post turned out to be advice based on my experiences, so the usual disclaimers apply. And feel free to leave a comment if you have any feedback!&lt;/p&gt;
&lt;h3&gt;The basics&lt;/h3&gt;
&lt;h4&gt;use an IDE&lt;/h4&gt;
&lt;p&gt;An IDE is not just an advanced text editor. It understands your code - to a degree, since it's not interpreting, compiling or executing the code. So not only allows an IDE you to manipulate your code as text, it also allows you to manipulate your code as code.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/2019/how-this-tester-writes-code/"&gt;Read more…&lt;/a&gt; (14 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>heuristics</category><category>IDEs</category><category>programming</category><category>python</category><category>test automation</category><guid>https://smallsheds.garden/blog/2019/how-this-tester-writes-code/</guid><pubDate>Sat, 08 Jun 2019 16:21:38 GMT</pubDate></item><item><title>Solving Black Box Puzzle 31 with data analysis</title><link>https://smallsheds.garden/blog/2019/solving-black-box-puzzle-31-with-data-analysis/</link><dc:creator>Joep Schuurkes</dc:creator><description>&lt;div&gt;&lt;p&gt;&lt;a href="https://twitter.com/workroomprds"&gt;James Lyndsay&lt;/a&gt; has created a number of amazing &lt;a href="http://blackboxpuzzles.workroomprds.com/"&gt;Black Box Puzzles&lt;/a&gt;: tiny applications that challenge you to figure out what they do. (You can support him in creating more of these at &lt;a href="https://www.patreon.com/workroomprds"&gt;his Patreon page&lt;/a&gt;.) Two of these Puzzles, &lt;a href="http://blackboxpuzzles.workroomprds.com/puzzle29/"&gt;29&lt;/a&gt; and &lt;a href="http://blackboxpuzzles.workroomprds.com/puzzle31/"&gt;31&lt;/a&gt;, not only have a GUI to explore, but also an API.&lt;/p&gt;
&lt;p&gt;And that gave me an idea. If you explore these Puzzles through their GUI, you start from the inputs. You try out different inputs in the hope of discovering a pattern in the outputs. And then that pattern feeds back into your exploration.&lt;br&gt;
With an API, however - and because of the nature of Puzzle 31 - it becomes easy to get the outputs for all possible combinations of inputs. Which means you can start your exploration from the outputs instead of the inputs.&lt;/p&gt;
&lt;p&gt;Before I tell you how and what I did, three important remarks.&lt;br&gt;
First of all, I will be spoiling the solution to the Puzzle in this blog post. So this is the right moment to go and solve &lt;a href="http://blackboxpuzzles.workroomprds.com/puzzle31/"&gt;Puzzle 31&lt;/a&gt; for yourself first. Or at least go play a bit with it, so you have an idea what the inputs and outputs are.&lt;br&gt;
Secondly, I had already solved the Puzzle through the GUI a few months ago. So it was more of a "Can I find the solution this way as well?" than a "Can I find the solution?" thing.&lt;br&gt;
Finally, the code and the spreadsheet I created (linked throughout, also available on GitHub &lt;a href="https://github.com/j19sch/blackbox-puzzle-31"&gt;here&lt;/a&gt;), are not very clean. I thought about tidying them up, but my two reasons for not doing so are (1) laziness; (2) the way they are now gives a more honest picture of what I did.&lt;/p&gt;
&lt;p&gt;&lt;a href="https://smallsheds.garden/blog/2019/solving-black-box-puzzle-31-with-data-analysis/"&gt;Read more…&lt;/a&gt; (18 min remaining to read)&lt;/p&gt;&lt;/div&gt;</description><category>black box puzzle</category><category>data analysis</category><category>exploratory testing</category><category>python</category><category>test automation</category><guid>https://smallsheds.garden/blog/2019/solving-black-box-puzzle-31-with-data-analysis/</guid><pubDate>Sun, 28 Apr 2019 11:16:34 GMT</pubDate></item></channel></rss>